const express = require('express');
const bcrypt = require('bcrypt');
const db = require('../db');



const router = express.Router();

// R√©cup√©rer toutes les t√¢ches d'une entreprise sp√©cifique
router.get('/tasks-by-owner/:ownerId', async (req, res) => {
    const ownerId = parseInt(req.params.ownerId, 10);

    if (isNaN(ownerId)) {
        return res.status(400).json({ error: "L'ID du propri√©taire est invalide" });
    }

    try {
        const query = `
           SELECT 
            t.id, t.title, t.date_debut, t.date_fin, t.statut, t.priorite,
            c.company_name AS company,
            IFNULL(GROUP_CONCAT(DISTINCT cat.name), '') AS categories,
            IFNULL(GROUP_CONCAT(DISTINCT i.name), '') AS intervenants
        FROM tasks t
        JOIN clients c ON t.company = c.id
        LEFT JOIN task_categories tc ON t.id = tc.task_id
        LEFT JOIN categories cat ON tc.category_id = cat.id
        LEFT JOIN task_intervenants ti ON t.id = ti.task_id
        LEFT JOIN intervenant i ON ti.intervenant_id = i.id
        WHERE c.proprietaire = ?
        GROUP BY t.id
        ORDER BY t.date_debut DESC;


        `;

        const [tasks] = await db.query(query, [ownerId]);

        if (tasks.length === 0) {
            return res.status(404).json({ message: 'Aucune t√¢che trouv√©e pour cet utilisateur' });
        }

        res.json(tasks);
    } catch (error) {
        console.error('Erreur SQL :', error);
        res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des t√¢ches', details: error.message });
    }
});



const generateTaskId = () => {
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let taskId = '';
    for (let i = 0; i < 11; i++) {
        taskId += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return taskId;
};
const moment = require('moment');


// ‚úÖ Route pour ajouter une t√¢che
router.post('/add-task', async (req, res) => {
    try {
        // üîπ R√©cup√©ration des donn√©es du front-end
        let { title, company, priorite, categories, intervenants, date_debut, date_fin, statut } = req.body;

        // üîπ V√©rifications des champs obligatoires
        if (!title || !company || !priorite || !categories.length || !intervenants.length || !date_debut || !date_fin) {
            return res.status(400).json({ error: 'Tous les champs sont requis' });
        }

        if (!Array.isArray(categories) || !Array.isArray(intervenants)) {
            return res.status(400).json({ error: 'Les cat√©gories et les intervenants doivent √™tre des tableaux' });
        }

        if (!moment(date_debut, 'YYYY-MM-DDTHH:mm', true).isValid() || 
            !moment(date_fin, 'YYYY-MM-DDTHH:mm', true).isValid()) {
            return res.status(400).json({ error: 'Les dates doivent √™tre au format YYYY-MM-DDTHH:mm' });
        }

        // üîπ Formatage des dates
        const formattedDateDebut = moment(date_debut, "YYYY-MM-DDTHH:mm").format('YYYY-MM-DD HH:mm:ss');
        const formattedDateFin = moment(date_fin, "YYYY-MM-DDTHH:mm").format('YYYY-MM-DD HH:mm:ss');

        // üîπ V√©rification de la priorit√© (conversion texte ‚Üí ID)
        if (isNaN(priorite)) {
            const [result] = await db.query("SELECT id FROM priorit√© WHERE Type = ?", [priorite]);
            if (result.length === 0) {
                return res.status(400).json({ error: "Priorit√© invalide" });
            }
            priorite = result[0].id;
        }

        // üîπ V√©rification de l'entreprise (conversion nom ‚Üí ID)
        const [companyData] = await db.query("SELECT id FROM clients WHERE company_name = ?", [company]);
        if (companyData.length === 0) {
            return res.status(400).json({ error: "L'entreprise sp√©cifi√©e n'existe pas" });
        }
        company = companyData[0].id;

        // üîπ G√©n√©ration d‚Äôun ID unique et timestamp
        const taskId = generateTaskId();
        const timestamp = Date.now();

        // üîπ Ins√©rer la t√¢che dans `tasks`
        await db.query(`
            INSERT INTO tasks (id, title, company, priorite, date_debut, date_fin, statut, timestamp)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `, [taskId, title, company, priorite, formattedDateDebut, formattedDateFin, statut, timestamp]);

        // üîπ R√©cup√©ration des IDs des cat√©gories
        const categoryIds = [];
        for (const categoryName of categories) {
            const [categoryResult] = await db.query("SELECT id FROM categories WHERE name = ?", [categoryName]);
            if (categoryResult.length === 0) {
                return res.status(400).json({ error: `Cat√©gorie '${categoryName}' invalide` });
            }
            categoryIds.push(categoryResult[0].id);
        }

        // üîπ Insertion dans `task_categories`
        for (const categoryId of categoryIds) {
            await db.query(`
                INSERT INTO task_categories (task_id, category_id, sous_statut)
                VALUES (?, ?, ?)
            `, [taskId, categoryId, 'En attente']);
        }

        // üîπ R√©cup√©ration des IDs des intervenants
        const intervenantIds = [];
        for (const intervenantName of intervenants) {
            const [intervenantResult] = await db.query("SELECT id FROM intervenant WHERE name = ?", [intervenantName]);
            if (intervenantResult.length === 0) {
                return res.status(400).json({ error: `Intervenant '${intervenantName}' invalide` });
            }
            intervenantIds.push(intervenantResult[0].id);
        }

        // üîπ Insertion dans `task_intervenants`
        for (const intervenantId of intervenantIds) {
            await db.query(`
                INSERT INTO task_intervenants (task_id, intervenant_id)
                VALUES (?, ?)
            `, [taskId, intervenantId]);
        }

        // ‚úÖ R√©ponse de succ√®s
        res.status(201).json({ message: 'T√¢che ajout√©e avec succ√®s', taskId });

    } catch (error) {
        console.error("Erreur MySQL :", error);
        res.status(500).json({ error: 'Erreur lors de l\'ajout de la t√¢che', details: error.sqlMessage });
    }
});






// R√©cup√©rer une t√¢che sp√©cifique par son ID
router.get('/:id', async (req, res) => {
  const taskId = req.params.id;
  try {
      const [task] = await db.query('SELECT * FROM tasks WHERE id = ?', [taskId]);
      if (task.length === 0) {
          return res.status(404).json({ error: 'T√¢che non trouv√©e' });
      }
      res.json(task[0]);
  } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration de la t√¢che' });
  }
});

// R√©cup√©rer toutes les t√¢ches d'un intervenant sp√©cifique
router.get('/intervenant/:id', async (req, res) => {
  const intervenantId = req.params.id;
  try {
      const [tasks] = await db.query('SELECT * FROM tasks WHERE intervenants = ?', [intervenantId]);
      res.json(tasks);
  } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la r√©cup√©ration des t√¢ches' });
  }
});

// Modifier une t√¢che
router.put('/:id', async (req, res) => {
  const taskId = req.params.id;
  const { title, categories, Priorit√©, intervenants, company, date_debut, date_fin, statut } = req.body;
  try {
      await db.query(
          'UPDATE tasks SET title = ?, categories = ?, Priorit√© = ?, intervenants = ?, company = ?, date_debut = ?, date_fin = ?, statut = ? WHERE id = ?',
          [title, categories, Priorit√©, intervenants, company, date_debut, date_fin, statut, taskId]
      );
      res.json({ message: 'T√¢che mise √† jour avec succ√®s' });
  } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la mise √† jour de la t√¢che' });
  }
});

// Supprimer une t√¢che
router.delete('/:id', async (req, res) => {
  const taskId = req.params.id;
  try {
      await db.query('DELETE FROM tasks WHERE id = ?', [taskId]);
      res.json({ message: 'T√¢che supprim√©e avec succ√®s' });
  } catch (error) {
      res.status(500).json({ error: 'Erreur lors de la suppression de la t√¢che' });
  }
});

//route pour compter les taches 
router.get('/count-tasks/:ownerId', async (req, res) => {
  const ownerId = req.params.ownerId;

  try {
      const query = `
          SELECT COUNT(*) AS total 
          FROM tasks
          JOIN clients ON tasks.company = clients.id
          WHERE clients.proprietaire = ?
      `;

      console.log("Requ√™te SQL ex√©cut√©e :", query);
      console.log("Valeur de ownerId :", ownerId);

      const [rows] = await db.query(query, [ownerId]);
      res.json({ total: rows[0].total });
  } catch (error) {
      console.error('Erreur lors du comptage des t√¢ches:', error);
      res.status(500).json({ error: 'Erreur lors du comptage des t√¢ches', details: error.message });
  }
});


  
module.exports = router;
